import { join } from "@projectbasalt/core"
import { autoid, Database } from "./Database"
import { Model } from "./Model"

/**
 * Remove the excess `/` before and after a path.
 * 
 * @version 1.0.0
 */
export type EscapePath<Path extends string>
	= Path extends `/${infer RealPath extends string}/`
		? RealPath
	: Path extends `${infer RealPath extends string}/`
		? RealPath
	: Path extends `/${infer RealPath extends string}`
		? RealPath
	: Path

/**
 * Find the path to the last collection in the path.
 * (e.g `PathCollection<"myCollection/myId/mySubCollection/mySubId">` returns `"myCollection/myId/mySubCollection"`)
 * 
 * @version 1.0.0
 */
export type PathCollection<Path extends string, PathSegments extends string[] = Split<EscapePath<Path>, "/">>
	= PathSegments extends [infer CollectionId extends string, infer DocumentId extends string, ...infer Tail extends [string, ...string[]]]
		? `${CollectionId}/${DocumentId}/${PathCollection<Path, Tail>}`
	: PathSegments extends [infer Head extends string, ...([string] | [])]
		? Head
		: ""

/**
 * Find the path's id.
 * (e.g. `PathId<"myCollection/myId">` returns `"myId"`)
 * 
 * @version 1.0.0
 */
export type PathId<Path extends string, DefaultValue extends string = never, PathSegments extends string[] = Split<EscapePath<Path>, "/">>
	= PathSegments extends [string, string, ...infer Tail extends [string, string, ...string[]]]
		? PathId<Path, DefaultValue, Tail>
	: PathSegments extends [string, infer Id extends string]
		? Id
		: DefaultValue

/**
 * Get the path to a collection id.
 * 
 * @version 1.0.0
 */
export type PathGroup<GroupId extends string, Tree extends Database.Tree, PathHistory extends string = "", Keys extends keyof Tree & string = keyof Tree & string>
	= Keys extends Keys
		?
		string extends Keys
		? never
		: (
			(
				GroupId extends Keys
					? `${PathHistory}${GroupId}`
					: never
			)
			|
			(
				Tree[Keys] extends Model<any, infer SubTree, any>
				?
					{
						0: never
						1: PathGroup<GroupId, SubTree, `${PathHistory}${Keys}/${string}/`>
					}[{} extends SubTree ? 0 : 1]
				: never
			)
		)
		: never

/**
 * Join together a list of path segments.
 * 
 * @version 1.0.0
 */
export type PathJoin<PathSegments extends string[]> = Join<{ [Key in keyof PathSegments]: EscapePath<PathSegments[Key]> }, "/">

/**
 * Get the path to the parent.
 * If the child is a DocumentPath, the parent will be a CollectionPath.
 * Otherwise if the child is CollectionPath, the parent will be a DocumentPath.
 * 
 * @version 1.0.0
 */
export type PathParent<Path extends string, PathSegments extends string[] = Split<EscapePath<Path>, "/">>
	= PathSegments extends [...infer BasePath extends string[], infer Parent extends string, string]
		? Join<[...BasePath, Parent], "/">
		: never

/**
 * Get the model value type at a certain path.
 * 
 * @version 1.0.0
 */
export type PathValue<
	Path extends string,
	Tree extends Database.Tree,
	PathSegments extends string[] = Split<EscapePath<Path>, "/">
>
	= PathSegments extends [infer Collection extends string, infer Id extends string, ...infer RestKeys extends [string, ...string[]]]
		? Collection extends keyof Tree
			? Tree[Collection] extends Model<any, infer SubTree, infer Ids>
				? PathValue<
						Path,
						Id extends keyof Ids
							? Ids[Id] extends Model<any, infer CustomSubTree, any>
								? CustomSubTree
								: SubTree
							: SubTree,
						RestKeys
					>
				: never
			: never
	: PathSegments extends [infer Collection, ...infer Rest extends ([] | [string])]
		? Collection extends keyof Tree
			? Tree[Collection] extends Model<infer Value, any, infer Ids>
				? Rest extends [infer Id extends string]
					? Id extends keyof Ids
						? Ids[Id] extends Model<infer Value>
							? Value
							: Ids[Id]
						: Value
					: Value
			: Tree[Collection] extends infer Value
				? Value
				: never
			: never
		: never

/**
 * Get the path of the collection pointed by the full path.
 * 
 * @version 1.0.0
 */
export const collectionPath = <PATH extends string>(collectionPath: PATH): PathCollection<PATH> =>
{
	const pathSegments = path(collectionPath).split("/")
	const lastIndex = pathSegments.length - 1
	const endIndex = (lastIndex % 2) === 0 ? undefined : -1
	return pathSegments.slice(0, endIndex).join("/") as any
}

/**
 * Remove the optional `/` before and after the path.
 * 
 * @version 1.0.0
 */
export const path = <Path extends string>(path: Path): EscapePath<Path> =>
	path.match(/(?:\/)?((?:\w+\/)*\w+)(?:\/)?/)?.[1] ?? path as any

/**
 * Fetch the document id of the path.
 * Returns a new autogenerated id if the path is a collection path.
 * 
 * @version 1.0.0
 */
export const pathId = <Path extends string>(documentPath: Path): PathId<Path, string> =>
{
	const pathSegments = path(documentPath).split("/")
	return (pathSegments.length % 2) === 0 && pathSegments[pathSegments.length - 1] || autoid() as any
}

/**
 * Join together a list of path segments.
 * 
 * @version 1.0.0
 */
export const pathJoin = <PathSegments extends string[]>(...pathSegments: PathSegments): PathJoin<PathSegments> =>
	join(pathSegments.map(pathSegment => path(pathSegment)), "/") as any

/**
 * Split a path into the smallest path segments.
 * 
 * @version 1.0.0
 */
export const pathSplit = <Path extends string>(fullPath: Path): Split<EscapePath<Path>, "/"> =>
	path(fullPath).split("/") as any

/**
 * Get the path of the parent.
 * 
 * @version 1.0.0
 */
export const parentPath = <PATH extends string>(fullPath: PATH): PathParent<PATH> =>
	pathJoin(...pathSplit(fullPath).slice(0, -1)) as any